import { RegulatoryReport } from '../regulatory-report.entity';
import { ReportStatus } from '../../value-objects/report-status.vo';
import { ReportType } from '../../value-objects/report-type.vo';
import { ReportGeneratedEvent } from '../../events/report-generated.event';
import { ReportSubmittedEvent } from '../../events/report-submitted.event';
import { ReportOverdueEvent } from '../../events/report-overdue.event';

describe('RegulatoryReport Entity', () => {
  const validId = 'report-123';
  const validOrganizationId = 'org-456';
  const validRegulatoryAgency = 'EPA';
  const validReportingPeriod = 'Q1-2024';
  const validReportingPeriodStart = new Date('2024-01-01');
  const validReportingPeriodEnd = new Date('2024-03-31');
  const validDueDate = new Date('2024-04-15');
  const validUserId = 'user-789';
  const validWellId = 'well-101';

  describe('Constructor', () => {
    it('should create report with required fields', () => {
      const reportType = ReportType.PRODUCTION;

      const report = new RegulatoryReport(
        validId,
        validOrganizationId,
        reportType,
        validRegulatoryAgency,
        validReportingPeriod,
        validReportingPeriodStart,
        validReportingPeriodEnd,
        validDueDate,
      );

      expect(report.id).toBe(validId);
      expect(report.organizationId).toBe(validOrganizationId);
      expect(report.reportType).toBe(reportType);
      expect(report.regulatoryAgency).toBe(validRegulatoryAgency);
      expect(report.reportingPeriod).toBe(validReportingPeriod);
      expect(report.reportingPeriodStart).toBe(validReportingPeriodStart);
      expect(report.reportingPeriodEnd).toBe(validReportingPeriodEnd);
      expect(report.dueDate).toBe(validDueDate);
      expect(report.status).toBe(ReportStatus.DRAFT);
      expect(report.priority).toBe('normal');
      expect(report.submissionMethod).toBe('electronic');
      expect(report.validationStatus).toBe('pending');
      expect(report.complianceStatus).toBe('unknown');
      expect(report.paymentStatus).toBe('not_required');
      expect(report.isAutoGenerated).toBe(false);
      expect(report.autoSubmissionEnabled).toBe(false);
      expect(report.retryCount).toBe(0);
      expect(report.maxRetries).toBe(3);
      expect(report.createdAt).toBeInstanceOf(Date);
      expect(report.updatedAt).toBeInstanceOf(Date);
    });
  });

  describe('Factory Method - create', () => {
    it('should create report with basic options', () => {
      const reportType = ReportType.ENVIRONMENTAL;
      const gracePeriodEnd = new Date('2024-04-20');

      const report = RegulatoryReport.create(
        validOrganizationId,
        reportType,
        validRegulatoryAgency,
        validReportingPeriod,
        validReportingPeriodStart,
        validReportingPeriodEnd,
        validDueDate,
        {
          wellId: validWellId,
          reportSubType: 'monthly',
          priority: 'high',
          gracePeriodEnd,
          isAutoGenerated: true,
          autoSubmissionEnabled: true,
        },
      );

      expect(report.organizationId).toBe(validOrganizationId);
      expect(report.reportType).toBe(reportType);
      expect(report.wellId).toBe(validWellId);
      expect(report.reportSubType).toBe('monthly');
      expect(report.priority).toBe('high');
      expect(report.gracePeriodEnd).toBe(gracePeriodEnd);
      expect(report.isAutoGenerated).toBe(true);
      expect(report.autoSubmissionEnabled).toBe(true);
    });

    it('should create report with default values', () => {
      const reportType = ReportType.PRODUCTION;

      const report = RegulatoryReport.create(
        validOrganizationId,
        reportType,
        validRegulatoryAgency,
        validReportingPeriod,
        validReportingPeriodStart,
        validReportingPeriodEnd,
        validDueDate,
      );

      expect(report.wellId).toBeUndefined();
      expect(report.reportSubType).toBeUndefined();
      expect(report.priority).toBe('normal');
      expect(report.isAutoGenerated).toBe(false);
      expect(report.autoSubmissionEnabled).toBe(false);
    });
  });

  describe('Business Methods', () => {
    let report: RegulatoryReport;

    beforeEach(() => {
      const reportType = ReportType.PRODUCTION;
      report = new RegulatoryReport(
        validId,
        validOrganizationId,
        reportType,
        validRegulatoryAgency,
        validReportingPeriod,
        validReportingPeriodStart,
        validReportingPeriodEnd,
        validDueDate,
      );
    });

    describe('generateReport', () => {
      it('should generate report and raise domain event', () => {
        const reportData = { production: 1000, units: 'bbl' };
        const metadata = { version: '1.0' };

        report.generateReport(reportData, validUserId, metadata);

        expect(report.status).toBe(ReportStatus.GENERATING);
        expect(report.generatedAt).toBeInstanceOf(Date);
        expect(report.generatedByUserId).toBe(validUserId);
        expect(report.reportData).toBe(reportData);
        expect(report.reportMetadata).toBe(metadata);

        const domainEvents = report.getDomainEvents();
        expect(domainEvents).toHaveLength(1);
        expect(domainEvents[0]).toBeInstanceOf(ReportGeneratedEvent);
        const event = domainEvents[0] as ReportGeneratedEvent;
        expect(event.reportType).toBe('production');
        expect(event.regulatoryAgency).toBe(validRegulatoryAgency);
        expect(event.reportData).toBe(reportData);
      });

      it('should throw error for invalid status transition', () => {
        report.status = ReportStatus.SUBMITTED;

        expect(() => {
          report.generateReport({}, validUserId);
        }).toThrow('Cannot generate report in status: submitted');
      });
    });

    describe('markAsGenerated', () => {
      beforeEach(() => {
        report.status = ReportStatus.GENERATING;
      });

      it('should mark report as generated', () => {
        report.markAsGenerated();

        expect(report.status).toBe(ReportStatus.GENERATED);
        expect(report.updatedAt).toBeInstanceOf(Date);
      });

      it('should throw error for invalid status transition', () => {
        report.status = ReportStatus.ACCEPTED;

        expect(() => {
          report.markAsGenerated();
        }).toThrow('Cannot mark report as generated in status: accepted');
      });
    });

    describe('submitForReview', () => {
      beforeEach(() => {
        report.status = ReportStatus.GENERATED;
      });

      it('should submit for review', () => {
        report.submitForReview(validUserId);

        expect(report.status).toBe(ReportStatus.REVIEWING);
        expect(report.reviewedByUserId).toBe(validUserId);
        expect(report.reviewedAt).toBeInstanceOf(Date);
      });

      it('should throw error for invalid status transition', () => {
        report.status = ReportStatus.DRAFT;

        expect(() => {
          report.submitForReview(validUserId);
        }).toThrow('Cannot submit for review in status: draft');
      });
    });

    describe('approveReport', () => {
      beforeEach(() => {
        report.status = ReportStatus.REVIEWING;
      });

      it('should approve report', () => {
        report.approveReport();

        expect(report.status).toBe(ReportStatus.APPROVED);
      });

      it('should throw error for invalid status transition', () => {
        report.status = ReportStatus.DRAFT;

        expect(() => {
          report.approveReport();
        }).toThrow('Cannot approve report in status: draft');
      });
    });

    describe('rejectReport', () => {
      beforeEach(() => {
        report.status = ReportStatus.REVIEWING;
      });

      it('should reject report with validation errors', () => {
        const validationErrors = [{ field: 'data', message: 'Invalid' }];

        report.rejectReport(validationErrors);

        expect(report.status).toBe(ReportStatus.REJECTED);
        expect(report.validationStatus).toBe('invalid');
        expect(report.validationErrors).toBe(validationErrors);
      });

      it('should reject report without errors', () => {
        report.rejectReport();

        expect(report.status).toBe(ReportStatus.REJECTED);
        expect(report.validationStatus).toBe('invalid');
        expect(report.validationErrors).toBeUndefined();
      });

      it('should throw error for invalid status transition', () => {
        report.status = ReportStatus.DRAFT;

        expect(() => {
          report.rejectReport();
        }).toThrow('Cannot reject report in status: draft');
      });
    });

    describe('submitReport', () => {
      beforeEach(() => {
        report.status = ReportStatus.APPROVED;
      });

      it('should submit report and raise domain event', () => {
        const submissionMethod = 'api';
        const externalSubmissionId = 'ext-123';

        report.submitReport(
          validUserId,
          submissionMethod,
          externalSubmissionId,
        );

        expect(report.status).toBe(ReportStatus.SUBMITTED);
        expect(report.submittedByUserId).toBe(validUserId);
        expect(report.submittedAt).toBeInstanceOf(Date);
        expect(report.submissionMethod).toBe(submissionMethod);
        expect(report.externalSubmissionId).toBe(externalSubmissionId);

        const domainEvents = report.getDomainEvents();
        expect(domainEvents).toHaveLength(1);
        expect(domainEvents[0]).toBeInstanceOf(ReportSubmittedEvent);
        const event = domainEvents[0] as ReportSubmittedEvent;
        expect(event.externalSubmissionId).toBe(externalSubmissionId);
      });

      it('should submit report with default submission method', () => {
        report.submitReport(validUserId);

        expect(report.submissionMethod).toBe('electronic');
      });

      it('should throw error for invalid status transition', () => {
        report.status = ReportStatus.DRAFT;

        expect(() => {
          report.submitReport(validUserId);
        }).toThrow('Cannot submit report in status: draft');
      });
    });

    describe('markAsAccepted', () => {
      beforeEach(() => {
        report.status = ReportStatus.SUBMITTED;
      });

      it('should mark report as accepted', () => {
        const confirmationNumber = 'CONF-123';

        report.markAsAccepted(confirmationNumber);

        expect(report.status).toBe(ReportStatus.ACCEPTED);
        expect(report.confirmationNumber).toBe(confirmationNumber);
        expect(report.complianceStatus).toBe('compliant');
      });

      it('should mark report as accepted without confirmation number', () => {
        report.markAsAccepted();

        expect(report.confirmationNumber).toBeUndefined();
      });

      it('should throw error for invalid status transition', () => {
        report.status = ReportStatus.DRAFT;

        expect(() => {
          report.markAsAccepted();
        }).toThrow('Cannot accept report in status: draft');
      });
    });

    describe('checkForOverdue', () => {
      it('should mark report as overdue when past due date', () => {
        const pastDueReport = new RegulatoryReport(
          validId,
          validOrganizationId,
          ReportType.PRODUCTION,
          validRegulatoryAgency,
          validReportingPeriod,
          validReportingPeriodStart,
          validReportingPeriodEnd,
          new Date('2023-01-01'), // Past due date
        );

        pastDueReport.checkForOverdue();

        expect(pastDueReport.status).toBe(ReportStatus.OVERDUE);

        const domainEvents = pastDueReport.getDomainEvents();
        expect(domainEvents).toHaveLength(1);
        expect(domainEvents[0]).toBeInstanceOf(ReportOverdueEvent);
      });

      it('should not mark as overdue if already terminal', () => {
        const terminalReport = new RegulatoryReport(
          validId,
          validOrganizationId,
          ReportType.PRODUCTION,
          validRegulatoryAgency,
          validReportingPeriod,
          validReportingPeriodStart,
          validReportingPeriodEnd,
          new Date('2023-01-01'),
        );
        terminalReport.status = ReportStatus.ACCEPTED;

        terminalReport.checkForOverdue();

        expect(terminalReport.status).toBe(ReportStatus.ACCEPTED);
      });

      it('should not mark as overdue if already overdue', () => {
        const overdueReport = new RegulatoryReport(
          validId,
          validOrganizationId,
          ReportType.PRODUCTION,
          validRegulatoryAgency,
          validReportingPeriod,
          validReportingPeriodStart,
          validReportingPeriodEnd,
          new Date('2023-01-01'),
        );
        overdueReport.status = ReportStatus.OVERDUE;

        overdueReport.checkForOverdue();

        expect(overdueReport.status).toBe(ReportStatus.OVERDUE);
      });

      it('should use grace period end if set', () => {
        const graceReport = new RegulatoryReport(
          validId,
          validOrganizationId,
          ReportType.PRODUCTION,
          validRegulatoryAgency,
          validReportingPeriod,
          validReportingPeriodStart,
          validReportingPeriodEnd,
          new Date('2024-01-01'),
        );
        (graceReport as any)._gracePeriodEnd = new Date('2023-01-01');

        graceReport.checkForOverdue();

        expect(graceReport.status).toBe(ReportStatus.OVERDUE);
      });
    });

    describe('retrySubmission', () => {
      it('should increment retry count', () => {
        report.retrySubmission();

        expect(report.retryCount).toBe(1);
        expect(report.lastRetryAt).toBeInstanceOf(Date);
      });

      it('should throw error when max retries exceeded', () => {
        report.retryCount = 3;

        expect(() => {
          report.retrySubmission();
        }).toThrow('Maximum retry attempts (3) exceeded');
      });
    });

    describe('setValidationResult', () => {
      it('should set validation result', () => {
        const validationErrors = [{ field: 'test' }];

        report.setValidationResult('invalid', validationErrors);

        expect(report.validationStatus).toBe('invalid');
        expect(report.validationErrors).toBe(validationErrors);
      });
    });

    describe('setComplianceStatus', () => {
      it('should set compliance status', () => {
        report.setComplianceStatus('compliant');

        expect(report.complianceStatus).toBe('compliant');
      });
    });

    describe('attachFile', () => {
      it('should attach file to report', () => {
        const attachment = { filename: 'test.pdf', size: 1024 };

        report.attachFile(attachment);

        const attachments = report.attachments as Record<string, unknown>[];
        expect(attachments).toBeDefined();
        expect(attachments).toHaveLength(1);
        expect(attachments[0]?.filename).toBe('test.pdf');
        expect(attachments[0]?.attachedAt).toBeInstanceOf(Date);
      });

      it('should initialize attachments array if undefined', () => {
        report.attachFile({ filename: 'test.pdf' });

        const attachments = report.attachments as Record<string, unknown>[];
        expect(attachments).toBeDefined();
        expect(attachments).toHaveLength(1);
      });
    });

    describe('associatePermit', () => {
      it('should associate permit', () => {
        const permitId = 'permit-123';

        report.associatePermit(permitId);

        expect(report.permitId).toBe(permitId);
      });
    });

    describe('associateIncident', () => {
      it('should associate incident', () => {
        const incidentId = 'incident-123';

        report.associateIncident(incidentId);

        expect(report.incidentId).toBe(incidentId);
      });
    });

    describe('associateEnvironmentalMonitoring', () => {
      it('should associate environmental monitoring', () => {
        const monitoringId = 'monitoring-123';

        report.associateEnvironmentalMonitoring(monitoringId);

        expect(report.environmentalMonitoringId).toBe(monitoringId);
      });
    });

    describe('associateWasteManagement', () => {
      it('should associate waste management', () => {
        const wasteId = 'waste-123';

        report.associateWasteManagement(wasteId);

        expect(report.wasteManagementId).toBe(wasteId);
      });
    });

    describe('scheduleNextAutoGeneration', () => {
      it('should schedule next auto generation', () => {
        const nextDate = new Date('2024-05-01');

        report.scheduleNextAutoGeneration(nextDate);

        expect(report.nextAutoGeneration).toBe(nextDate);
      });
    });
  });

  describe('Business Logic Queries', () => {
    let report: RegulatoryReport;

    beforeEach(() => {
      const reportType = ReportType.PRODUCTION;
      report = new RegulatoryReport(
        validId,
        validOrganizationId,
        reportType,
        validRegulatoryAgency,
        validReportingPeriod,
        validReportingPeriodStart,
        validReportingPeriodEnd,
        validDueDate,
      );
    });

    describe('isOverdue', () => {
      it('should return true when past due date', () => {
        const overdueReport = new RegulatoryReport(
          validId,
          validOrganizationId,
          ReportType.PRODUCTION,
          validRegulatoryAgency,
          validReportingPeriod,
          validReportingPeriodStart,
          validReportingPeriodEnd,
          new Date('2023-01-01'), // Past
        );

        expect(overdueReport.isOverdue()).toBe(true);
      });

      it('should return false when not past due date', () => {
        const futureReport = new RegulatoryReport(
          validId,
          validOrganizationId,
          ReportType.PRODUCTION,
          validRegulatoryAgency,
          validReportingPeriod,
          validReportingPeriodStart,
          validReportingPeriodEnd,
          new Date('2026-01-01'), // Future
        );

        expect(futureReport.isOverdue()).toBe(false);
      });

      it('should use grace period end if set', () => {
        const graceReport = new RegulatoryReport(
          validId,
          validOrganizationId,
          ReportType.PRODUCTION,
          validRegulatoryAgency,
          validReportingPeriod,
          validReportingPeriodStart,
          validReportingPeriodEnd,
          new Date('2026-01-01'),
        );
        (graceReport as any)._gracePeriodEnd = new Date('2023-01-01');

        expect(graceReport.isOverdue()).toBe(true);
      });

      it('should return false for terminal status', () => {
        const terminalReport = new RegulatoryReport(
          validId,
          validOrganizationId,
          ReportType.PRODUCTION,
          validRegulatoryAgency,
          validReportingPeriod,
          validReportingPeriodStart,
          validReportingPeriodEnd,
          new Date('2023-01-01'),
        );
        terminalReport.status = ReportStatus.ACCEPTED;

        expect(terminalReport.isOverdue()).toBe(false);
      });
    });

    describe('isAutoGeneratable', () => {
      it('should return true when auto generated and time reached', () => {
        report.isAutoGenerated = true;
        report.nextAutoGeneration = new Date('2023-01-01');

        expect(report.isAutoGeneratable()).toBe(true);
      });

      it('should return false when not auto generated', () => {
        report.isAutoGenerated = false;
        report.nextAutoGeneration = new Date('2023-01-01');

        expect(report.isAutoGeneratable()).toBe(false);
      });

      it('should return false when no next generation date', () => {
        report.isAutoGenerated = true;
        report.nextAutoGeneration = undefined;

        expect(report.isAutoGeneratable()).toBe(false);
      });
    });

    describe('canAutoSubmit', () => {
      it('should return true when auto submission enabled and approved', () => {
        report.autoSubmissionEnabled = true;
        report.status = ReportStatus.APPROVED;

        expect(report.canAutoSubmit()).toBe(true);
      });

      it('should return false when auto submission disabled', () => {
        report.autoSubmissionEnabled = false;
        report.status = ReportStatus.APPROVED;

        expect(report.canAutoSubmit()).toBe(false);
      });

      it('should return false when not approved', () => {
        report.autoSubmissionEnabled = true;
        report.status = ReportStatus.GENERATED;

        expect(report.canAutoSubmit()).toBe(false);
      });
    });

    describe('requiresValidation', () => {
      it('should return true when validation pending and generated', () => {
        report.validationStatus = 'pending';
        report.status = ReportStatus.GENERATED;

        expect(report.requiresValidation()).toBe(true);
      });

      it('should return false when validation not pending', () => {
        report.validationStatus = 'valid';
        report.status = ReportStatus.GENERATED;

        expect(report.requiresValidation()).toBe(false);
      });
    });

    describe('hasValidationErrors', () => {
      it('should return true when invalid and has errors', () => {
        report.validationStatus = 'invalid';
        report.validationErrors = [{ field: 'test' }];

        expect(report.hasValidationErrors()).toBe(true);
      });

      it('should return false when valid', () => {
        report.validationStatus = 'valid';
        report.validationErrors = [{ field: 'test' }];

        expect(report.hasValidationErrors()).toBe(false);
      });
    });

    describe('isCompliant', () => {
      it('should return true when compliance status is compliant', () => {
        report.complianceStatus = 'compliant';

        expect(report.isCompliant()).toBe(true);
      });

      it('should return false when not compliant', () => {
        report.complianceStatus = 'non_compliant';

        expect(report.isCompliant()).toBe(false);
      });
    });

    describe('isReadyForSubmission', () => {
      it('should return true when all conditions met', () => {
        report.status = ReportStatus.APPROVED;
        report.validationStatus = 'valid';
        report.filingFee = undefined; // No fee required

        expect(report.isReadyForSubmission()).toBe(true);
      });

      it('should return false when not approved', () => {
        report.status = ReportStatus.GENERATED;
        report.validationStatus = 'valid';

        expect(report.isReadyForSubmission()).toBe(false);
      });

      it('should return false when validation not valid', () => {
        report.status = ReportStatus.APPROVED;
        report.validationStatus = 'invalid';

        expect(report.isReadyForSubmission()).toBe(false);
      });

      it('should return false when fee not paid', () => {
        report.status = ReportStatus.APPROVED;
        report.validationStatus = 'valid';
        report.filingFee = 100;
        report.paymentStatus = 'pending';

        expect(report.isReadyForSubmission()).toBe(false);
      });
    });
  });

  describe('Persistence Methods', () => {
    it('should convert to persistence format', () => {
      const reportType = ReportType.PRODUCTION;
      const report = new RegulatoryReport(
        validId,
        validOrganizationId,
        reportType,
        validRegulatoryAgency,
        validReportingPeriod,
        validReportingPeriodStart,
        validReportingPeriodEnd,
        validDueDate,
      );

      const persistenceData = report.toPersistence();

      expect(persistenceData.id).toBe(validId);
      expect(persistenceData.organizationId).toBe(validOrganizationId);
      expect(persistenceData.reportType).toBe('production');
      expect(persistenceData.status).toBe('draft');
      expect(persistenceData.reportingPeriod).toBe(validReportingPeriod);
      expect(persistenceData.dueDate).toBe(validDueDate);
    });

    it('should create from persistence data', () => {
      const persistenceData = {
        id: validId,
        organizationId: validOrganizationId,
        reportType: 'environmental',
        regulatoryAgency: validRegulatoryAgency,
        reportingPeriod: validReportingPeriod,
        reportingPeriodStart: validReportingPeriodStart,
        reportingPeriodEnd: validReportingPeriodEnd,
        dueDate: validDueDate,
        status: 'generated',
        priority: 'high',
        generatedAt: new Date('2024-01-01'),
        generatedByUserId: validUserId,
        createdAt: new Date('2023-12-01'),
        updatedAt: new Date('2024-01-01'),
        wellId: validWellId,
        reportSubType: 'monthly',
        validationStatus: 'valid',
      };

      const report = RegulatoryReport.fromPersistence(persistenceData);

      expect(report.id).toBe(validId);
      expect(report.organizationId).toBe(validOrganizationId);
      expect(report.reportType.value).toBe('environmental');
      expect(report.status.value).toBe('generated');
      expect(report.priority).toBe('high');
      expect(report.generatedByUserId).toBe(validUserId);
      expect(report.wellId).toBe(validWellId);
      expect(report.reportSubType).toBe('monthly');
      expect(report.validationStatus).toBe('valid');
    });
  });

  describe('Entity Interface', () => {
    it('should implement getId method', () => {
      const reportType = ReportType.PRODUCTION;
      const report = new RegulatoryReport(
        validId,
        validOrganizationId,
        reportType,
        validRegulatoryAgency,
        validReportingPeriod,
        validReportingPeriodStart,
        validReportingPeriodEnd,
        validDueDate,
      );

      const id = report.getId();
      expect(id.getValue()).toBe(validId);
    });
  });
});
