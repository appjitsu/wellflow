import { Inject, Injectable } from '@nestjs/common';
import type { NodePgDatabase } from 'drizzle-orm/node-postgres';
import { eq, and, sql, desc, asc, gte, lte, lt, or } from 'drizzle-orm';
import type { RegulatoryReportRepository } from '../../domain/repositories/regulatory-report.repository';
import { RegulatoryReport } from '../../domain/entities/regulatory-report.entity';
import { regulatoryReports as regulatoryReportsTable } from '../../database/schemas/regulatory-reports';
import type * as schema from '../../database/schema';

/**
 * Drizzle-based Regulatory Report Repository Implementation
 * Implements the RegulatoryReportRepository interface using Drizzle ORM
 */
@Injectable()
export class RegulatoryReportRepositoryImpl
  implements RegulatoryReportRepository
{
  constructor(
    @Inject('DATABASE_CONNECTION')
    private readonly db: NodePgDatabase<typeof schema>,
  ) {}

  /**
   * Save a regulatory report to the repository
   */
  async save(report: RegulatoryReport): Promise<void> {
    const data = {
      id: report.id,
      organizationId: report.organizationId,
      wellId: report.wellId,
      reportType: report.reportType.value,
      reportSubType: report.reportSubType,
      regulatoryAgency: report.regulatoryAgency,
      reportingPeriod: report.reportingPeriod,
      reportingPeriodStart: report.reportingPeriodStart
        .toISOString()
        .split('T')[0] as string,
      reportingPeriodEnd: report.reportingPeriodEnd
        .toISOString()
        .split('T')[0] as string,
      dueDate: report.dueDate.toISOString().split('T')[0] as string,
      gracePeriodEnd:
        report.gracePeriodEnd?.toISOString().split('T')[0] || null,
      status: report.status.value,
      priority: report.priority,
      generatedAt: report.generatedAt || null,
      generatedByUserId: report.generatedByUserId || null,
      reviewedAt: report.reviewedAt || null,
      reviewedByUserId: report.reviewedByUserId || null,
      submittedAt: report.submittedAt || null,
      submittedByUserId: report.submittedByUserId || null,
      externalSubmissionId: report.externalSubmissionId || null,
      confirmationNumber: report.confirmationNumber || null,
      submissionMethod: report.submissionMethod,
      reportData: report.reportData || null,
      reportMetadata: report.reportMetadata || null,
      attachments: report.attachments || null,
      validationStatus: report.validationStatus,
      validationErrors: report.validationErrors || null,
      complianceStatus: report.complianceStatus,
      filingFee: report.filingFee?.toString() || null,
      paymentStatus: report.paymentStatus,
      isAutoGenerated: report.isAutoGenerated,
      autoSubmissionEnabled: report.autoSubmissionEnabled,
      nextAutoGeneration: report.nextAutoGeneration || null,
      retryCount: report.retryCount,
      lastRetryAt: report.lastRetryAt || null,
      maxRetries: report.maxRetries,
      notes: report.notes || null,
      createdAt: report.createdAt,
      updatedAt: report.updatedAt,
      permitId: report.permitId || null,
      incidentId: report.incidentId || null,
      environmentalMonitoringId: report.environmentalMonitoringId || null,
      wasteManagementId: report.wasteManagementId || null,
    };

    await this.db
      .insert(regulatoryReportsTable)
      .values(data)
      .onConflictDoUpdate({
        target: regulatoryReportsTable.id,
        set: {
          status: report.status.value,
          priority: report.priority,
          generatedAt: report.generatedAt,
          generatedByUserId: report.generatedByUserId,
          reviewedAt: report.reviewedAt,
          reviewedByUserId: report.reviewedByUserId,
          submittedAt: report.submittedAt,
          submittedByUserId: report.submittedByUserId,
          externalSubmissionId: report.externalSubmissionId,
          confirmationNumber: report.confirmationNumber,
          submissionMethod: report.submissionMethod,
          reportData: report.reportData,
          reportMetadata: report.reportMetadata,
          attachments: report.attachments,
          validationStatus: report.validationStatus,
          validationErrors: report.validationErrors,
          complianceStatus: report.complianceStatus,
          filingFee: report.filingFee?.toString(),
          paymentStatus: report.paymentStatus,
          retryCount: report.retryCount,
          lastRetryAt: report.lastRetryAt,
          notes: report.notes,
          updatedAt: new Date(),
        },
      });
  }

  /**
   * Save multiple regulatory reports within a unit of work
   */
  async saveMany(reports: RegulatoryReport[]): Promise<void> {
    for (const report of reports) {
      await this.save(report);
    }
  }

  /**
   * Find a regulatory report by its ID
   */
  async findById(id: string): Promise<RegulatoryReport | null> {
    const result = await this.db
      .select()
      .from(regulatoryReportsTable)
      .where(eq(regulatoryReportsTable.id, id))
      .limit(1);

    if (result.length === 0 || !result[0]) {
      return null;
    }

    return RegulatoryReport.fromPersistence(result[0]);
  }

  /**
   * Find regulatory reports by organization
   */
  // eslint-disable-next-line sonarjs/cognitive-complexity
  async findByOrganizationId(
    organizationId: string,
    options?: {
      limit?: number;
      offset?: number;
      reportType?: string;
      status?: string;
      regulatoryAgency?: string;
      wellId?: string;
      startDate?: Date;
      endDate?: Date;
      priority?: string;
      isOverdue?: boolean;
      isAutoGenerated?: boolean;
    },
  ): Promise<RegulatoryReport[]> {
    const conditions = [
      eq(regulatoryReportsTable.organizationId, organizationId),
    ];

    if (options?.reportType) {
      conditions.push(
        eq(regulatoryReportsTable.reportType, options.reportType),
      );
    }

    if (options?.status) {
      conditions.push(eq(regulatoryReportsTable.status, options.status));
    }

    if (options?.regulatoryAgency) {
      conditions.push(
        eq(regulatoryReportsTable.regulatoryAgency, options.regulatoryAgency),
      );
    }

    if (options?.wellId) {
      conditions.push(eq(regulatoryReportsTable.wellId, options.wellId));
    }

    if (options?.startDate) {
      conditions.push(
        sql`${regulatoryReportsTable.reportingPeriodStart} >= ${options.startDate.toISOString().split('T')[0]}`,
      );
    }

    if (options?.endDate) {
      conditions.push(
        sql`${regulatoryReportsTable.reportingPeriodEnd} <= ${options.endDate.toISOString().split('T')[0]}`,
      );
    }

    if (options?.priority) {
      conditions.push(eq(regulatoryReportsTable.priority, options.priority));
    }

    if (options?.isOverdue !== undefined) {
      const today = new Date().toISOString().substring(0, 10);
      if (options.isOverdue) {
        conditions.push(lt(regulatoryReportsTable.dueDate, today));
      } else {
        conditions.push(gte(regulatoryReportsTable.dueDate, today));
      }
    }

    if (options?.isAutoGenerated !== undefined) {
      conditions.push(
        eq(regulatoryReportsTable.isAutoGenerated, options.isAutoGenerated),
      );
    }

    let query = this.db
      .select()
      .from(regulatoryReportsTable)
      .where(and(...conditions))
      .orderBy(desc(regulatoryReportsTable.dueDate));

    if (options?.offset) {
      query = query.offset(options.offset) as typeof query;
    }

    if (options?.limit) {
      query = query.limit(options.limit) as typeof query;
    }

    const results = await query;
    return results.map((row) => RegulatoryReport.fromPersistence(row));
  }

  /**
   * Find regulatory reports by well ID
   */
  async findByWellId(wellId: string): Promise<RegulatoryReport[]> {
    const results = await this.db
      .select()
      .from(regulatoryReportsTable)
      .where(eq(regulatoryReportsTable.wellId, wellId))
      .orderBy(desc(regulatoryReportsTable.dueDate));

    return results.map((row) => RegulatoryReport.fromPersistence(row));
  }

  /**
   * Find regulatory reports by report type
   */
  async findByReportType(
    reportType: string,
    organizationId?: string,
  ): Promise<RegulatoryReport[]> {
    const conditions = [eq(regulatoryReportsTable.reportType, reportType)];

    if (organizationId) {
      conditions.push(
        eq(regulatoryReportsTable.organizationId, organizationId),
      );
    }

    const results = await this.db
      .select()
      .from(regulatoryReportsTable)
      .where(and(...conditions))
      .orderBy(desc(regulatoryReportsTable.dueDate));

    return results.map((row) => RegulatoryReport.fromPersistence(row));
  }

  /**
   * Find regulatory reports by regulatory agency
   */
  async findByRegulatoryAgency(
    regulatoryAgency: string,
    organizationId?: string,
  ): Promise<RegulatoryReport[]> {
    const conditions = [
      eq(regulatoryReportsTable.regulatoryAgency, regulatoryAgency),
    ];

    if (organizationId) {
      conditions.push(
        eq(regulatoryReportsTable.organizationId, organizationId),
      );
    }

    const results = await this.db
      .select()
      .from(regulatoryReportsTable)
      .where(and(...conditions))
      .orderBy(desc(regulatoryReportsTable.dueDate));

    return results.map((row) => RegulatoryReport.fromPersistence(row));
  }

  /**
   * Find regulatory reports by status
   */
  async findByStatus(
    status: string,
    organizationId?: string,
  ): Promise<RegulatoryReport[]> {
    const conditions = [eq(regulatoryReportsTable.status, status)];

    if (organizationId) {
      conditions.push(
        eq(regulatoryReportsTable.organizationId, organizationId),
      );
    }

    const results = await this.db
      .select()
      .from(regulatoryReportsTable)
      .where(and(...conditions))
      .orderBy(desc(regulatoryReportsTable.dueDate));

    return results.map((row) => RegulatoryReport.fromPersistence(row));
  }

  /**
   * Find overdue regulatory reports
   */
  async findOverdue(
    organizationId?: string,
    gracePeriodDays?: number,
  ): Promise<RegulatoryReport[]> {
    const gracePeriod = gracePeriodDays || 0;
    const overdueDate = new Date();
    overdueDate.setDate(overdueDate.getDate() - gracePeriod);

    const conditions = [
      sql`${regulatoryReportsTable.dueDate} < ${overdueDate.toISOString().split('T')[0]}`,
      or(
        eq(regulatoryReportsTable.status, 'draft'),
        eq(regulatoryReportsTable.status, 'generated'),
        eq(regulatoryReportsTable.status, 'reviewing'),
      ),
    ];

    if (organizationId) {
      conditions.push(
        eq(regulatoryReportsTable.organizationId, organizationId),
      );
    }

    const results = await this.db
      .select()
      .from(regulatoryReportsTable)
      .where(and(...conditions))
      .orderBy(asc(regulatoryReportsTable.dueDate));

    return results.map((row) => RegulatoryReport.fromPersistence(row));
  }

  /**
   * Find regulatory reports due within a certain number of days
   */
  async findDueWithinDays(
    daysFromNow: number,
    organizationId?: string,
  ): Promise<RegulatoryReport[]> {
    const futureDate = new Date();
    futureDate.setDate(futureDate.getDate() + daysFromNow);

    const conditions = [
      sql`${regulatoryReportsTable.dueDate} <= ${futureDate.toISOString().split('T')[0]}`,
      sql`${regulatoryReportsTable.dueDate} >= ${new Date().toISOString().split('T')[0]}`,
      or(
        eq(regulatoryReportsTable.status, 'draft'),
        eq(regulatoryReportsTable.status, 'generated'),
        eq(regulatoryReportsTable.status, 'reviewing'),
      ),
    ];

    if (organizationId) {
      conditions.push(
        eq(regulatoryReportsTable.organizationId, organizationId),
      );
    }

    const results = await this.db
      .select()
      .from(regulatoryReportsTable)
      .where(and(...conditions))
      .orderBy(asc(regulatoryReportsTable.dueDate));

    return results.map((row) => RegulatoryReport.fromPersistence(row));
  }

  /**
   * Find regulatory reports that are ready for auto-generation
   */
  async findReadyForAutoGeneration(
    organizationId?: string,
  ): Promise<RegulatoryReport[]> {
    const now = new Date();

    const conditions = [
      eq(regulatoryReportsTable.isAutoGenerated, true),
      lte(regulatoryReportsTable.nextAutoGeneration, now),
      or(
        eq(regulatoryReportsTable.status, 'draft'),
        eq(regulatoryReportsTable.status, 'generated'),
      ),
    ];

    if (organizationId) {
      conditions.push(
        eq(regulatoryReportsTable.organizationId, organizationId),
      );
    }

    const results = await this.db
      .select()
      .from(regulatoryReportsTable)
      .where(and(...conditions))
      .orderBy(asc(regulatoryReportsTable.nextAutoGeneration));

    return results.map((row) => RegulatoryReport.fromPersistence(row));
  }

  /**
   * Find regulatory reports that are ready for auto-submission
   */
  async findReadyForAutoSubmission(
    organizationId?: string,
  ): Promise<RegulatoryReport[]> {
    const conditions = [
      eq(regulatoryReportsTable.autoSubmissionEnabled, true),
      eq(regulatoryReportsTable.status, 'approved'),
      eq(regulatoryReportsTable.validationStatus, 'valid'),
    ];

    if (organizationId) {
      conditions.push(
        eq(regulatoryReportsTable.organizationId, organizationId),
      );
    }

    const results = await this.db
      .select()
      .from(regulatoryReportsTable)
      .where(and(...conditions))
      .orderBy(asc(regulatoryReportsTable.dueDate));

    return results.map((row) => RegulatoryReport.fromPersistence(row));
  }

  /**
   * Find regulatory reports that require validation
   */
  async findRequiringValidation(
    organizationId?: string,
  ): Promise<RegulatoryReport[]> {
    const conditions = [
      or(
        eq(regulatoryReportsTable.validationStatus, 'pending'),
        eq(regulatoryReportsTable.validationStatus, 'invalid'),
      ),
      or(
        eq(regulatoryReportsTable.status, 'generated'),
        eq(regulatoryReportsTable.status, 'reviewing'),
      ),
    ];

    if (organizationId) {
      conditions.push(
        eq(regulatoryReportsTable.organizationId, organizationId),
      );
    }

    const results = await this.db
      .select()
      .from(regulatoryReportsTable)
      .where(and(...conditions))
      .orderBy(desc(regulatoryReportsTable.generatedAt));

    return results.map((row) => RegulatoryReport.fromPersistence(row));
  }

  /**
   * Find regulatory reports by permit ID
   */
  async findByPermitId(permitId: string): Promise<RegulatoryReport[]> {
    const results = await this.db
      .select()
      .from(regulatoryReportsTable)
      .where(eq(regulatoryReportsTable.permitId, permitId))
      .orderBy(desc(regulatoryReportsTable.dueDate));

    return results.map((row) => RegulatoryReport.fromPersistence(row));
  }

  /**
   * Find regulatory reports by incident ID
   */
  async findByIncidentId(incidentId: string): Promise<RegulatoryReport[]> {
    const results = await this.db
      .select()
      .from(regulatoryReportsTable)
      .where(eq(regulatoryReportsTable.incidentId, incidentId))
      .orderBy(desc(regulatoryReportsTable.dueDate));

    return results.map((row) => RegulatoryReport.fromPersistence(row));
  }

  /**
   * Find regulatory reports by environmental monitoring ID
   */
  async findByEnvironmentalMonitoringId(
    monitoringId: string,
  ): Promise<RegulatoryReport[]> {
    const results = await this.db
      .select()
      .from(regulatoryReportsTable)
      .where(eq(regulatoryReportsTable.environmentalMonitoringId, monitoringId))
      .orderBy(desc(regulatoryReportsTable.dueDate));

    return results.map((row) => RegulatoryReport.fromPersistence(row));
  }

  /**
   * Find regulatory reports by waste management ID
   */
  async findByWasteManagementId(wasteId: string): Promise<RegulatoryReport[]> {
    const results = await this.db
      .select()
      .from(regulatoryReportsTable)
      .where(eq(regulatoryReportsTable.wasteManagementId, wasteId))
      .orderBy(desc(regulatoryReportsTable.dueDate));

    return results.map((row) => RegulatoryReport.fromPersistence(row));
  }

  /**
   * Count regulatory reports by status for an organization
   */
  async countByStatus(organizationId: string): Promise<Record<string, number>> {
    const results = await this.db
      .select({
        status: regulatoryReportsTable.status,
        count: sql<number>`count(*)`,
      })
      .from(regulatoryReportsTable)
      .where(eq(regulatoryReportsTable.organizationId, organizationId))
      .groupBy(regulatoryReportsTable.status);

    const statusCounts: Record<string, number> = {};
    for (const result of results) {
      statusCounts[result.status] = result.count;
    }

    return statusCounts;
  }

  /**
   * Count regulatory reports by type for an organization
   */
  async countByReportType(
    organizationId: string,
  ): Promise<Record<string, number>> {
    const results = await this.db
      .select({
        reportType: regulatoryReportsTable.reportType,
        count: sql<number>`count(*)`,
      })
      .from(regulatoryReportsTable)
      .where(eq(regulatoryReportsTable.organizationId, organizationId))
      .groupBy(regulatoryReportsTable.reportType);

    const typeCounts: Record<string, number> = {};
    for (const result of results) {
      typeCounts[result.reportType] = result.count;
    }

    return typeCounts;
  }

  /**
   * Count regulatory reports by regulatory agency for an organization
   */
  async countByRegulatoryAgency(
    organizationId: string,
  ): Promise<Record<string, number>> {
    const results = await this.db
      .select({
        regulatoryAgency: regulatoryReportsTable.regulatoryAgency,
        count: sql<number>`count(*)`,
      })
      .from(regulatoryReportsTable)
      .where(eq(regulatoryReportsTable.organizationId, organizationId))
      .groupBy(regulatoryReportsTable.regulatoryAgency);

    const agencyCounts: Record<string, number> = {};
    for (const result of results) {
      agencyCounts[result.regulatoryAgency] = result.count;
    }

    return agencyCounts;
  }

  /**
   * Check if a regulatory report exists for the given parameters
   */
  async existsByParameters(
    organizationId: string,
    reportType: string,
    reportingPeriodStart: Date,
    reportingPeriodEnd: Date,
    excludeId?: string,
  ): Promise<boolean> {
    const conditions = [
      eq(regulatoryReportsTable.organizationId, organizationId),
      eq(regulatoryReportsTable.reportType, reportType),
      sql`${regulatoryReportsTable.reportingPeriodStart} = ${reportingPeriodStart.toISOString().split('T')[0]}`,
      sql`${regulatoryReportsTable.reportingPeriodEnd} = ${reportingPeriodEnd.toISOString().split('T')[0]}`,
    ];

    if (excludeId) {
      conditions.push(sql`${regulatoryReportsTable.id} != ${excludeId}`);
    }

    const result = await this.db
      .select({ count: sql<number>`count(*)` })
      .from(regulatoryReportsTable)
      .where(and(...conditions))
      .limit(1);

    return (result[0]?.count ?? 0) > 0;
  }

  /**
   * Delete a regulatory report by ID
   */
  async delete(id: string): Promise<void> {
    await this.db
      .delete(regulatoryReportsTable)
      .where(eq(regulatoryReportsTable.id, id));
  }

  /**
   * Get compliance statistics for an organization
   */
  // eslint-disable-next-line sonarjs/cognitive-complexity
  async getComplianceStatistics(
    organizationId: string,
    dateRange?: { start: Date; end: Date },
  ): Promise<{
    totalReports: number;
    submittedOnTime: number;
    submittedLate: number;
    overdue: number;
    complianceRate: number;
    byReportType: Record<
      string,
      { total: number; compliant: number; rate: number }
    >;
    byAgency: Record<
      string,
      { total: number; compliant: number; rate: number }
    >;
  }> {
    const conditions = [
      eq(regulatoryReportsTable.organizationId, organizationId),
    ];

    if (dateRange) {
      conditions.push(
        sql`${regulatoryReportsTable.reportingPeriodStart} >= ${dateRange.start.toISOString().split('T')[0]}`,
        sql`${regulatoryReportsTable.reportingPeriodEnd} <= ${dateRange.end.toISOString().split('T')[0]}`,
      );
    }

    const whereCondition = and(...conditions);

    const results = await this.db
      .select()
      .from(regulatoryReportsTable)
      .where(whereCondition);

    const stats = {
      totalReports: results.length,
      submittedOnTime: 0,
      submittedLate: 0,
      overdue: 0,
      complianceRate: 0,
      byReportType: {} as Record<
        string,
        { total: number; compliant: number; rate: number }
      >,
      byAgency: {} as Record<
        string,
        { total: number; compliant: number; rate: number }
      >,
    };

    for (const report of results) {
      const isSubmitted = ['submitted', 'accepted'].includes(report.status);
      const isOverdue = new Date(report.dueDate) < new Date() && !isSubmitted;

      if (isSubmitted) {
        const submittedOnTime =
          new Date(report.submittedAt as Date) <= new Date(report.dueDate);
        if (submittedOnTime) {
          stats.submittedOnTime++;
        } else {
          stats.submittedLate++;
        }
      } else if (isOverdue) {
        stats.overdue++;
      }

      // Group by report type
      if (!stats.byReportType[report.reportType]) {
        stats.byReportType[report.reportType] = {
          total: 0,
          compliant: 0,
          rate: 0,
        };
      }
      (
        stats.byReportType[report.reportType] as {
          total: number;
          compliant: number;
          rate: number;
        }
      ).total++;
      if (isSubmitted) {
        (
          stats.byReportType[report.reportType] as {
            total: number;
            compliant: number;
            rate: number;
          }
        ).compliant++;
      }

      // Group by agency
      if (!stats.byAgency[report.regulatoryAgency]) {
        stats.byAgency[report.regulatoryAgency] = {
          total: 0,
          compliant: 0,
          rate: 0,
        };
      }
      (
        stats.byAgency[report.regulatoryAgency] as {
          total: number;
          compliant: number;
          rate: number;
        }
      ).total++;
      if (isSubmitted) {
        (
          stats.byAgency[report.regulatoryAgency] as {
            total: number;
            compliant: number;
            rate: number;
          }
        ).compliant++;
      }
    }

    // Calculate rates
    const totalSubmitted = stats.submittedOnTime + stats.submittedLate;
    stats.complianceRate =
      stats.totalReports > 0 ? (totalSubmitted / stats.totalReports) * 100 : 0;

    for (const type of Object.keys(stats.byReportType)) {
      // eslint-disable-next-line security/detect-object-injection
      const typeStats = stats.byReportType[type];
      if (typeStats) {
        typeStats.rate =
          typeStats.total > 0
            ? (typeStats.compliant / typeStats.total) * 100
            : 0;
      }
    }

    for (const agency of Object.keys(stats.byAgency)) {
      // eslint-disable-next-line security/detect-object-injection
      const agencyStats = stats.byAgency[agency];
      if (agencyStats) {
        agencyStats.rate =
          agencyStats.total > 0
            ? (agencyStats.compliant / agencyStats.total) * 100
            : 0;
      }
    }

    return stats;
  }
}
