/**
 * Database Relationships Tests
 *
 * Tests for foreign key relationships, joins, and data integrity
 */

import { Pool } from 'pg';
import { drizzle } from 'drizzle-orm/node-postgres';
import { eq, desc } from 'drizzle-orm';
import * as schema from '../schema';

describe('Database Relationships Tests', () => {
  let pool: Pool;
  let db: ReturnType<typeof drizzle>;
  // Helper function to generate unique API numbers
  const generateUniqueApiNumber = (): string => {
    const timestamp = Date.now().toString().slice(-6);
    const random = Math.floor(Math.random() * 1000)
      .toString()
      .padStart(3, '0');
    return `42123${timestamp}${random}`.slice(0, 14);
  };

  // Helper function to generate unique email addresses
  const generateUniqueEmail = (): string => {
    const timestamp = Date.now().toString().slice(-6);
    const random = Math.floor(Math.random() * 1000)
      .toString()
      .padStart(3, '0');
    return `tester${timestamp}${random}@test.com`;
  };

  beforeAll(async () => {
    pool = new Pool({
      host: process.env.TEST_DB_HOST || 'localhost',
      port: parseInt(process.env.TEST_DB_PORT || '5433'),
      user: process.env.TEST_DB_USER || 'postgres',
      password: process.env.TEST_DB_PASSWORD || 'password',
      database: process.env.TEST_DB_NAME || 'wellflow_test',
    });

    db = drizzle(pool, { schema });

    // Verify database connection
    await db.select().from(schema.organizations).limit(1);
  });

  afterAll(async () => {
    await pool.end();
  });

  // Note: Removed aggressive beforeEach cleanup that was interfering with other tests
  // Individual tests will clean up their own data as needed

  describe('Organization Relationships', () => {
    test('should establish one-to-many relationship with users', async () => {
      const [org] = await db
        .insert(schema.organizations)
        .values({ name: 'Test Oil Company' })
        .returning();

      const users = [
        {
          organizationId: org.id,
          email: generateUniqueEmail(),
          firstName: 'John',
          lastName: 'Owner',
          role: 'owner' as const,
          isActive: true,
        },
        {
          organizationId: org.id,
          email: generateUniqueEmail(),
          firstName: 'Jane',
          lastName: 'Manager',
          role: 'manager' as const,
          isActive: true,
        },
      ];

      await db.insert(schema.users).values(users);

      // Query with relationship
      const orgWithUsers = await db
        .select()
        .from(schema.organizations)
        .leftJoin(
          schema.users,
          eq(schema.organizations.id, schema.users.organizationId),
        )
        .where(eq(schema.organizations.id, org.id));

      expect(orgWithUsers).toBeDefined();
      // Note: This simplified test just checks that the join works
      // In a real scenario, you'd aggregate the users separately
      expect(orgWithUsers.length).toBeGreaterThan(0);
    });

    test('should establish one-to-many relationship with wells', async () => {
      const [org] = await db
        .insert(schema.organizations)
        .values({ name: 'Test Oil Company' })
        .returning();

      const wells = [
        {
          organizationId: org.id,
          apiNumber: generateUniqueApiNumber(),
          wellName: 'Well #1',
          wellType: 'OIL' as const,
          status: 'ACTIVE' as const,
        },
        {
          organizationId: org.id,
          apiNumber: generateUniqueApiNumber(),
          wellName: 'Well #2',
          wellType: 'OIL' as const,
          status: 'ACTIVE' as const,
        },
      ];

      await db.insert(schema.wells).values(wells);

      // Query with relationship
      const orgWithWells = await db.query.organizations.findFirst({
        where: eq(schema.organizations.id, org.id),
        with: {
          wells: true,
        },
      });

      expect(orgWithWells).toBeDefined();
      expect(orgWithWells!.wells).toHaveLength(2);
      expect(orgWithWells!.wells[0]!.wellName).toBe('Well #1');
      expect(orgWithWells!.wells[1].wellName).toBe('Well #2');
    });
  });

  describe('Well Relationships', () => {
    let organizationId: string;
    let wellId: string;
    let userId: string;

    beforeEach(async () => {
      const [org] = await db
        .insert(schema.organizations)
        .values({ name: 'Test Oil Company' })
        .returning();
      organizationId = org.id;

      const [well] = await db
        .insert(schema.wells)
        .values({
          organizationId,
          apiNumber: generateUniqueApiNumber(),
          wellName: 'Relationship Test Well',
          wellType: 'OIL' as const,
          status: 'ACTIVE' as const,
        })
        .returning();
      wellId = well.id;

      // Create user for well tests
      const [user] = await db
        .insert(schema.users)
        .values({
          organizationId,
          email: generateUniqueEmail(),
          firstName: 'Test',
          lastName: 'User',
          role: 'pumper' as const,
          isActive: true,
        })
        .returning();
      userId = user.id;
    });

    test('should establish one-to-many relationship with production records', async () => {
      const productionRecords = [
        {
          organizationId,
          wellId,
          productionDate: '2024-01-15',
          oilVolume: '45.50',
          gasVolume: '325.75',
          waterVolume: '12.25',
          oilPrice: '75.50',
          gasPrice: '3.25',
          isEstimated: false,
        },
        {
          organizationId,
          wellId,
          productionDate: '2024-01-16',
          oilVolume: '48.25',
          gasVolume: '340.50',
          waterVolume: '15.75',
          oilPrice: '76.00',
          gasPrice: '3.30',
          isEstimated: false,
        },
      ];

      await db.insert(schema.productionRecords).values(productionRecords);

      // Query with relationship
      const wellWithProduction = await db.query.wells.findFirst({
        where: eq(schema.wells.id, wellId),
        with: {
          productionRecords: {
            orderBy: desc(schema.productionRecords.productionDate),
          },
        },
      });

      expect(wellWithProduction).toBeDefined();
      expect(wellWithProduction!.productionRecords).toHaveLength(2);
      expect(wellWithProduction!.productionRecords[0]!.productionDate).toBe(
        '2024-01-16',
      );
      expect(wellWithProduction!.productionRecords[1].productionDate).toBe(
        '2024-01-15',
      );
    });

    test('should establish one-to-many relationship with equipment', async () => {
      const equipment = [
        {
          wellId,
          equipmentName: 'Primary Pump',
          equipmentType: 'pump' as const,
          manufacturer: 'Weatherford',
          model: 'Model-123',
          serialNumber: 'SN-001',
          installationDate: '2024-01-01',
        },
        {
          wellId,
          equipmentName: 'Gas Separator',
          equipmentType: 'separator' as const,
          manufacturer: 'Cameron',
          model: 'Sep-456',
          serialNumber: 'SN-002',
          installationDate: '2024-01-01',
        },
      ];

      await db.insert(schema.equipment).values(equipment);

      // Query with relationship
      const wellWithEquipment = await db.query.wells.findFirst({
        where: eq(schema.wells.id, wellId),
        with: {
          equipment: true,
        },
      });

      expect(wellWithEquipment).toBeDefined();
      expect(wellWithEquipment!.equipment).toHaveLength(2);
      expect(wellWithEquipment!.equipment[0]!.equipmentType).toBe('pump');
      expect(wellWithEquipment!.equipment[1].equipmentType).toBe('separator');
    });

    test('should establish one-to-many relationship with well tests', async () => {
      const wellTests = [
        {
          wellId,
          conductedByUserId: userId,
          testDate: '2024-01-15',
          testType: 'production' as const,
          oilRate: '45.50',
          gasRate: '325.75',
          waterRate: '12.25',
          notes: 'Standard production test',
        },
        {
          wellId,
          conductedByUserId: userId,
          testDate: '2024-02-15',
          testType: 'pressure' as const,
          notes: 'Pressure buildup test',
        },
      ];

      await db.insert(schema.wellTests).values(wellTests);

      // Query with relationship
      const wellWithTests = await db.query.wells.findFirst({
        where: eq(schema.wells.id, wellId),
        with: {
          wellTests: {
            orderBy: desc(schema.wellTests.testDate),
          },
        },
      });

      expect(wellWithTests).toBeDefined();
      expect(wellWithTests!.wellTests).toHaveLength(2);
      expect(wellWithTests!.wellTests[0]!.testType).toBe('pressure');
      expect(wellWithTests!.wellTests[1].testType).toBe('production');
    });
  });

  describe('Lease-Partner Relationships', () => {
    let organizationId: string;
    let leaseId: string;
    let partner1Id: string;
    let partner2Id: string;

    beforeEach(async () => {
      const [org] = await db
        .insert(schema.organizations)
        .values({ name: 'Test Oil Company' })
        .returning();
      organizationId = org.id;

      const [lease] = await db
        .insert(schema.leases)
        .values({
          organizationId,
          name: 'Test Lease',
          lessor: 'Test Lessor LLC',
          lessee: 'Test Lessee Inc',
          acreage: '160.00',
          royaltyRate: '0.1875',
        })
        .returning();
      leaseId = lease.id;

      const partners = [
        {
          organizationId,
          partnerName: 'Partner One LLC',
          partnerCode: 'P001',
          partnerType: 'working_interest' as const,
          taxId: '12-3456789',
          isActive: true,
        },
        {
          organizationId,
          partnerName: 'Partner Two Inc',
          partnerCode: 'P002',
          partnerType: 'royalty_owner' as const,
          taxId: '98-7654321',
          isActive: true,
        },
      ];

      const createdPartners = await db
        .insert(schema.partners)
        .values(partners)
        .returning();

      partner1Id = createdPartners[0]!.id;
      partner2Id = createdPartners[1].id;
    });

    test('should establish many-to-many relationship through lease_partners', async () => {
      const leasePartners = [
        {
          leaseId,
          partnerId: partner1Id,
          workingInterestPercent: '0.7500',
          royaltyInterestPercent: '0.1250',
          netRevenueInterestPercent: '0.6250',
          effectiveDate: '2024-01-01',
        },
        {
          leaseId,
          partnerId: partner2Id,
          workingInterestPercent: '0.2500',
          royaltyInterestPercent: '0.1250',
          netRevenueInterestPercent: '0.1250',
          effectiveDate: '2024-01-01',
        },
      ];

      await db.insert(schema.leasePartners).values(leasePartners);

      // Query lease with partners
      const leaseWithPartners = await db.query.leases.findFirst({
        where: eq(schema.leases.id, leaseId),
        with: {
          leasePartners: {
            with: {
              partner: true,
            },
          },
        },
      });

      expect(leaseWithPartners).toBeDefined();
      expect(leaseWithPartners!.leasePartners).toHaveLength(2);
      expect(leaseWithPartners!.leasePartners[0]!.partner.partnerName).toBe(
        'Partner One LLC',
      );
      expect(leaseWithPartners!.leasePartners[1].partner.partnerName).toBe(
        'Partner Two Inc',
      );
      expect(leaseWithPartners!.leasePartners[0]!.workingInterestPercent).toBe(
        '0.75',
      );
      expect(leaseWithPartners!.leasePartners[1].workingInterestPercent).toBe(
        '0.25',
      );
    });

    test('should query partners with their leases', async () => {
      await db.insert(schema.leasePartners).values({
        leaseId,
        partnerId: partner1Id,
        workingInterestPercent: '1.0000',
        royaltyInterestPercent: '0.1250',
        netRevenueInterestPercent: '0.8750',
        effectiveDate: '2024-01-01',
      });

      // Query partner with leases
      const partnerWithLeases = await db.query.partners.findFirst({
        where: eq(schema.partners.id, partner1Id),
        with: {
          leasePartners: {
            with: {
              lease: true,
            },
          },
        },
      });

      expect(partnerWithLeases).toBeDefined();
      expect(partnerWithLeases!.leasePartners).toHaveLength(1);
      expect(partnerWithLeases!.leasePartners[0]!.lease.name).toBe(
        'Test Lease',
      );
      expect(partnerWithLeases!.leasePartners[0]!.workingInterestPercent).toBe(
        '1',
      );
    });
  });

  describe('Complex Multi-Table Relationships', () => {
    test('should query organization with all related data', async () => {
      // Create organization
      const [org] = await db
        .insert(schema.organizations)
        .values({ name: 'Complex Test Company' })
        .returning();

      // Create user
      await db.insert(schema.users).values({
        organizationId: org.id,
        email: generateUniqueEmail(),
        firstName: 'Admin',
        lastName: 'User',
        role: 'owner' as const,
        isActive: true,
      });

      // Create lease
      const [lease] = await db
        .insert(schema.leases)
        .values({
          organizationId: org.id,
          name: 'Complex Lease',
          lessor: 'Complex Lessor LLC',
          lessee: 'Complex Lessee Inc',
          acreage: '320.00',
          royaltyRate: '0.1875',
          effectiveDate: '2024-01-01',
        })
        .returning();

      // Create well
      const [well] = await db
        .insert(schema.wells)
        .values({
          organizationId: org.id,
          leaseId: lease.id,
          apiNumber: generateUniqueApiNumber(),
          wellName: 'Complex Well',
          wellType: 'OIL' as const,
          status: 'ACTIVE' as const,
        })
        .returning();

      // Create production record
      await db.insert(schema.productionRecords).values({
        organizationId: org.id,
        wellId: well.id,
        productionDate: '2024-01-15',
        oilVolume: '100.00',
        gasVolume: '500.00',
        waterVolume: '25.00',
        oilPrice: '80.00',
        gasPrice: '4.00',
      });

      // Query with deep relationships
      const complexQuery = await db.query.organizations.findFirst({
        where: eq(schema.organizations.id, org.id),
        with: {
          users: true,
          leases: {
            with: {
              wells: {
                with: {
                  productionRecords: true,
                },
              },
            },
          },
        },
      });

      expect(complexQuery).toBeDefined();
      expect(complexQuery!.users).toHaveLength(1);
      expect(complexQuery!.leases).toHaveLength(1);
      expect(complexQuery!.leases[0]!.wells).toHaveLength(1);
      expect(complexQuery!.leases[0]!.wells[0]!.productionRecords).toHaveLength(
        1,
      );
      expect(
        complexQuery!.leases[0]!.wells[0]!.productionRecords[0]!.oilVolume,
      ).toBe('100');
    });
  });

  describe('Foreign Key Constraint Enforcement', () => {
    test('should prevent deletion of referenced organization', async () => {
      const [org] = await db
        .insert(schema.organizations)
        .values({ name: 'Referenced Org' })
        .returning();

      await db.insert(schema.users).values({
        organizationId: org.id,
        email: generateUniqueEmail(),
        firstName: 'Test',
        lastName: 'User',
        role: 'owner' as const,
        isActive: true,
      });

      // Attempt to delete organization with dependent users
      await expect(
        db
          .delete(schema.organizations)
          .where(eq(schema.organizations.id, org.id)),
      ).rejects.toThrow();
    });

    test('should prevent insertion with invalid foreign key', async () => {
      const fakeOrgId = '00000000-0000-0000-0000-000000000000';

      // Attempt to create user with non-existent organization
      await expect(
        db.insert(schema.users).values({
          organizationId: fakeOrgId,
          email: generateUniqueEmail(),
          firstName: 'Orphan',
          lastName: 'User',
          role: 'owner' as const,
          isActive: true,
        }),
      ).rejects.toThrow();
    });
  });
});
